name: Process Manual Test

on:
  issues:
    types:        # run for newly openedÂ *and* edited issues
      - opened
      - edited

jobs:
  process-manual-test:
    runs-on: ubuntu-latest

    permissions:          # leastâ€‘privilege: we only touch issues
      issues:   write
      contents: read

    steps:
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: â¬‡ï¸  Checkout repo
      uses: actions/checkout@v3
      with:
        fetch-depth: 1

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: ðŸ“‹ Parse issueâ€‘form
      id: parse-issue
      uses: issue-ops/parser@v1.0.0
      with:
        body:             ${{ github.event.issue.body }}
        issue-form-template: manual-test-report.yml
        workspace:        ${{ github.workspace }}

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: ðŸ› ï¸  Build field set
      id: build-field-set
      run: |
        echo "os_used=${{   fromJson(steps.parse-issue.outputs.json).operating_system[0]        }}" >> "$GITHUB_OUTPUT"
        echo "lv_version=${{ fromJson(steps.parse-issue.outputs.json).labview_version_used[0]   }}" >> "$GITHUB_OUTPUT"
        echo "bitness=${{    fromJson(steps.parse-issue.outputs.json).labview_bitness[0]        }}" >> "$GITHUB_OUTPUT"
        echo "test_result=${{ fromJson(steps.parse-issue.outputs.json).test_result[0]           }}" >> "$GITHUB_OUTPUT"
        # notes can be multiline â€“ squash newlines so the API accepts it
        echo "notes=$(echo "${{ fromJson(steps.parse-issue.outputs.json).notes_or_screenshots_optional }}" | tr '\n' ' ')" >> "$GITHUB_OUTPUT"

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: ðŸ—‚ï¸  Update project fields
      uses: actions/github-script@v6
      id: update-project
      with:
        github-token: ${{ secrets.PROJECTS_PAT }}
        script: |
          /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
             GitHubâ€‘Script â€“ keep issue & project in sync
             â€¢ creates/locates the ProjectÂ V2 item
             â€¢ autoâ€‘creates missing text & singleâ€‘select fields
             â€¢ autoâ€‘creates missing select options
             â€¢ updates values with detailed logging
             â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
          const log  = m => core.info(`â„¹ï¸  ${m}`);
          const warn = m => core.warning(`âš ï¸  ${m}`);

          const orgLogin = process.env.ORG_LOGIN;
          const projectNumber = Number(process.env.PROJ_NUMBER);
          const contentId  = context.payload.issue.node_id;

          // 1Â â€“ locate the project
          log(`Locating ProjectÂ #${projectNumber} in org â€œ${orgLogin}â€ â€¦`);
          const pj = await github.graphql(`
            query($org:String!,$num:Int!){
              organization(login:$org){
                projectV2(number:$num){ id title }
              }
            }`,
            {org:orgLogin, num:projectNumber});
          const project = pj.organization?.projectV2;
          if (!project) return core.setFailed(`Project #${projectNumber} not found`);
          log(`Using project â€œ${project.title}â€`);
          const projectId = project.id;

          // 2Â â€“ add the issue to the project (or discover its item if itâ€™s already there)
          let itemId;
          try {
            const add = await github.graphql(`
              mutation($pid:ID!,$cid:ID!){
                addProjectV2ItemById(input:{projectId:$pid,contentId:$cid}){
                  item{ id }
                }
              }`,
              {pid:projectId, cid:contentId});
            itemId = add.addProjectV2ItemById.item.id;
            log(`Added new item ${itemId}`);
          } catch (err) {
            if (!/already exists/i.test(err.message)) throw err;   // unexpected error
            log('Issue already in project â€“ finding existing item â€¦');
            const search = await github.graphql(`
              query($pid:ID!,$first:Int!){
                node(id:$pid){
                  ... on ProjectV2{
                    items(first:$first){
                      nodes{
                        id
                        content{ ... on Issue{ id } ... on PullRequest{ id } }
                      }
                    }
                  }
                }
              }`,
              {pid:projectId, first:100});
            const hit = search.node.items.nodes.find(n => n.content?.id === contentId);
            if (!hit) return core.setFailed('Could not locate existing item.');
            itemId = hit.id;
            log(`Found item ${itemId}`);
          }

          // 3Â â€“ helpers to list / create fields & options
          async function listFields() {
            const res = await github.graphql(`
              query($pid:ID!){
                node(id:$pid){
                  ... on ProjectV2{
                    fields(first:100){
                      nodes{
                        id name dataType
                        ... on ProjectV2SingleSelectField{ options{ id name } }
                      }
                    }
                  }
                }
              }`,
              {pid:projectId});
            return res.node.fields.nodes;
          }
          async function createField(name,type){
            log(`Creating field â€œ${name}â€`);
            const res = await github.graphql(`
              mutation($pid:ID!,$name:String!,$type:ProjectV2CustomFieldDataType!){
                createProjectV2Field(input:{projectId:$pid,name:$name,dataType:$type}){
                  field{
                    id name dataType
                    ... on ProjectV2SingleSelectField{ options{ id name } }
                  }
                }
              }`,
              {pid:projectId,name,type});
            return res.createProjectV2Field.field;
          }
          async function ensureOption(field,optName){
            if (field.dataType !== 'SINGLE_SELECT') return null;
            let opt = field.options.find(o=>o.name===optName);
            if (opt) return opt.id;
            log(`Creating option â€œ${optName}â€ in â€œ${field.name}â€`);
            const res = await github.graphql(`
              mutation($pid:ID!,$fid:ID!,$name:String!){
                createProjectV2SingleSelectFieldOption(input:{
                  projectId:$pid,fieldId:$fid,name:$name
                }){
                  option{ id }
                }
              }`,
              {pid:projectId,fid:field.id,name:optName});
            return res.createProjectV2SingleSelectFieldOption.option.id;
          }
          async function setField(item, field, value){
            if (!value){ warn(`Value for â€œ${field.name}â€ empty â€“ skipped`); return; }
            const val = field.dataType==='SINGLE_SELECT'
              ? {singleSelectOptionId: await ensureOption(field,value)}
              : {text:String(value)};
            await github.graphql(`
              mutation($pid:ID!,$iid:ID!,$fid:ID!,$val:ProjectV2FieldValue!){
                updateProjectV2ItemFieldValue(input:{
                  projectId:$pid,itemId:$iid,fieldId:$fid,value:$val
                }){ clientMutationId }
              }`,
              {pid:projectId,iid:item,fid:field.id,val});
            log(`Set â€œ${field.name}â€ â†’ â€œ${value}â€`);
          }

          // 4Â â€“ desired field list
          const desired = [
            {name:'Operating System', value:process.env.OS_USED,     type:'TEXT'},
            {name:'LabVIEW Version',  value:process.env.LV_VERSION,  type:'TEXT'},
            {name:'LabVIEW Bitness',  value:process.env.BITNESS,     type:'TEXT'},
            {name:'Test Result',      value:process.env.TEST_RESULT, type:'SINGLE_SELECT'},
            {name:'Notes',            value:process.env.NOTES,       type:'TEXT'},
          ];

          let fields = await listFields();
          for (const d of desired){
            if (!d.value){ warn(`No value for â€œ${d.name}â€ â€“ skipping`); continue; }
            let field = fields.find(f=>f.name===d.name);
            if (!field){
              field = await createField(d.name, d.type);
              fields.push(field);
            }
            await setField(itemId, field, d.value);
          }

          log('ðŸŽ‰  Project item fully updated');
      env:
        ORG_LOGIN:          ni
        PROJ_NUMBER:        29
        OS_USED:            ${{ steps.build-field-set.outputs.os_used }}
        LV_VERSION:         ${{ steps.build-field-set.outputs.lv_version }}
        BITNESS:            ${{ steps.build-field-set.outputs.bitness }}
        TEST_RESULT:        ${{ steps.build-field-set.outputs.test_result }}
        NOTES:              ${{ steps.build-field-set.outputs.notes }}
