name: ManualÂ TestÂ Report

on:
  issues:
    types: [opened, edited]   # run on new issues and any later edits

permissions:                  # minimum permissions the job needs
  contents: read
  issues: write               # weâ€™ll update the issue title/labels if we want
  pull-requests: write

jobs:
  process-manual-test:
    if: contains(github.event.issue.title, '[Manual Test]')   # ignore unrelated issues
    runs-on: ubuntu-latest

    steps:
    #--------------------------------------------------------------------
    # 1) Check out the repository so we can read the issueâ€‘form template
    #--------------------------------------------------------------------
    - name: Checkout repository
      uses: actions/checkout@v3
      with:
        fetch-depth: 1

    #--------------------------------------------------------------------
    # 2) Parse the issueâ€‘form the tester just submitted
    #--------------------------------------------------------------------
    - name: Parse issue form
      id: parse
      uses: issue-ops/parser@v1.0.0
      with:
        body: ${{ github.event.issue.body }}
        issue-form-template: manual-test-report.yml   # <- path inside .github/ISSUE_TEMPLATE/
        workspace: ${{ github.workspace }}

    #--------------------------------------------------------------------
    # 3) Collect all values weâ€™ll push to the project
    #--------------------------------------------------------------------
    - name: Build field set
      id: build
      run: |
        {
          echo "test_id=${{ steps.parse.outputs.numeric_test_id }}"
          echo "estimate=${{ steps.parse.outputs.estimate_text }}"
          echo "lv_version=${{ steps.parse.outputs.labview_version }}"
          echo "bitness=${{ steps.parse.outputs.labview_bitness }}"
          echo "os_used=${{ steps.parse.outputs.os_used }}"
          echo "test_result=${{ steps.parse.outputs.test_result }}"
          echo "notes=${{ steps.parse.outputs.notes }}"
        } >> "$GITHUB_OUTPUT"

    #--------------------------------------------------------------------
    # 4) Push everything to the NI Actor Framework **organisation project**
    #    â€“ creates missing fields / options automatically and logs every step
    #--------------------------------------------------------------------
    - name: Update project fields
      uses: actions/github-script@v6
      env:
        PROJECT_ID: PVT_kwDOCgMyo84AFVsT          # â† nodeâ€‘ID for https://github.com/orgs/ni/projects/29
        TEST_ID:      ${{ steps.build.outputs.test_id }}
        ESTIMATE:     ${{ steps.build.outputs.estimate }}
        LV_VERSION:   ${{ steps.build.outputs.lv_version }}
        BITNESS:      ${{ steps.build.outputs.bitness }}
        OS_USED:      ${{ steps.build.outputs.os_used }}
        TEST_RESULT:  ${{ steps.build.outputs.test_result }}
        NOTES:        ${{ steps.build.outputs.notes }}
      with:
        github-token: ${{ secrets.PROJECTS_PAT }} # PAT needs â€œProjectsÂ (Read & Write)â€ + â€œIssuesÂ (Read)â€ scopes
        script: |
          const projectId   = process.env.PROJECT_ID;
          const contentId   = context.payload.issue.node_id;   // the issue itself
          const log         = (msg) => core.info(`  ${msg}`);

          // ------------------------------------------------------------
          // Helper 1: find or create a project item for the current issue
          // ------------------------------------------------------------
          async function ensureProjectItem() {
            const q = await github.graphql(`
              query ($projectId:ID!, $contentId:ID!) {
                node(id:$projectId) {
                  ... on ProjectV2 {
                    title
                    items(first:100, query:$contentId) {
                      nodes { id content { ... on Issue { id } } }
                    }
                  }
                }
              }`, {projectId, contentId});

            const projectTitle = q.node.title;
            let item = q.node.items.nodes.find(n => n.content && n.content.id === contentId);

            if (item) {
              log(`Found existing project item ${item.id} in â€œ${projectTitle}â€.`);
              return item.id;
            }

            log(`No item yet â€“ adding current issue to project â€œ${projectTitle}â€â€¦`);
            const add = await github.graphql(`
              mutation ($projectId:ID!, $contentId:ID!) {
                addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}) {
                  item { id }
                }
              }`, {projectId, contentId});
            return add.addProjectV2ItemById.item.id;
          }

          // ------------------------------------------------------------
          // Helper 2: list all existing projectâ€‘level custom fields
          // ------------------------------------------------------------
          async function getAllFields() {
            const res = await github.graphql(`
              query ($projectId:ID!) {
                node(id:$projectId) {
                  ... on ProjectV2 {
                    fields(first:100) {
                      nodes {
                        id name dataType
                        ... on ProjectV2SingleSelectField { options { id name } }
                      }
                    }
                  }
                }
              }`, {projectId});
            return res.node.fields.nodes;
          }

          // ------------------------------------------------------------
          // Helper 3: create a new field (text or singleâ€‘select)
          // ------------------------------------------------------------
          async function createField(name, type) {
            log(`Creating missing field â€œ${name}â€â€¦`);
            const mutation = type === 'TEXT'
              ? `mutation ($projectId:ID!, $name:String!) {
                   createProjectV2Field(input:{
                     projectId:$projectId, name:$name, dataType:TEXT
                   }) { field { id name dataType } }
                 }`
              : `mutation ($projectId:ID!, $name:String!) {
                   createProjectV2Field(input:{
                     projectId:$projectId, name:$name, dataType:SINGLE_SELECT,
                     singleSelectOptions:[{name:"Passed"},{name:"Failed"},{name:"Needs Review"}]
                   }) {
                     field { id name dataType ... on ProjectV2SingleSelectField { options { id name } } }
                   }
                 }`;
            const res = await github.graphql(mutation, {projectId, name});
            return res.createProjectV2Field.field;
          }

          // ------------------------------------------------------------
          // Helper 4: update (or set) a field value on the item
          // ------------------------------------------------------------
          async function setField(itemId, field, rawValue) {
            let valuePayload;

            if (field.dataType === 'SINGLE_SELECT') {
              let opt = field.options.find(o => o.name === rawValue);
              if (!opt) {
                log(`Adding option â€œ${rawValue}â€ to field â€œ${field.name}â€â€¦`);
                const addOpt = await github.graphql(`
                  mutation ($projectId:ID!, $fieldId:ID!, $name:String!) {
                    createProjectV2SingleSelectFieldOption(input:{
                      projectId:$projectId, fieldId:$fieldId, name:$name
                    }) { option { id name } }
                  }`, {projectId, fieldId: field.id, name: rawValue});
                opt = addOpt.createProjectV2SingleSelectFieldOption.option;
                field.options.push(opt);
              }
              valuePayload = { singleSelectOptionId: opt.id };
            } else {
              valuePayload = { text: rawValue };
            }

            await github.graphql(`
              mutation ($projectId:ID!, $itemId:ID!, $fieldId:ID!, $value:ProjectV2FieldValue!) {
                updateProjectV2ItemFieldValue(input:{
                  projectId:$projectId, itemId:$itemId, fieldId:$fieldId, value:$value
                }) { projectV2Item { id } }
              }`, {projectId, itemId, fieldId: field.id, value: valuePayload});

            log(`âœ… Set â€œ${field.name}â€ â†’ â€œ${rawValue}â€`);
          }

          // =========== MAIN ===========================================
          log('ðŸ” Locating / creating project item');
          const itemId   = await ensureProjectItem();
          log('ðŸ—‚  Gathering project fields');
          const fields   = await getAllFields();

          const wanted = [
            { name: 'TestID',           value: process.env.TEST_ID,     type: 'TEXT' },
            { name: 'Estimate',         value: process.env.ESTIMATE,    type: 'TEXT' },
            { name: 'Operating System', value: process.env.OS_USED,     type: 'TEXT' },
            { name: 'LabVIEW Version',  value: process.env.LV_VERSION,  type: 'TEXT' },
            { name: 'LabVIEW Bitness',  value: process.env.BITNESS,     type: 'TEXT' },
            { name: 'Notes',            value: process.env.NOTES,       type: 'TEXT' },
            { name: 'Test Result',      value: process.env.TEST_RESULT, type: 'SINGLE_SELECT' }
          ];

          log('âœï¸ Updating fields');
          for (const w of wanted) {
            if (!w.value) { log(`âš ï¸  Skipping â€œ${w.name}â€ â€“ no value provided`); continue; }

            let field = fields.find(f => f.name === w.name);
            if (!field) {
              field = await createField(w.name, w.type);
              fields.push(field);   // keep cache up to date
            }
            await setField(itemId, field, w.value);
          }

          log('ðŸŽ‰ All fields up to date!');
