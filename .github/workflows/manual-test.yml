name: ManualÂ TestÂ Report

on:
  issues:
    types: [opened, edited]          # run on new issues and any later edits

permissions:
  contents: read
  issues:   write
  pull-requests: write

jobs:
  process-manual-test:
    if: contains(github.event.issue.title, '[Manual Test]')
    runs-on: ubuntu-latest

    steps:
    #--------------------------------------------------------------------
    # 1) Check out repository so the issueâ€‘form template is available
    #--------------------------------------------------------------------
    - name: Checkout repository
      uses: actions/checkout@v3
      with: { fetch-depth: 1 }

    #--------------------------------------------------------------------
    # 2) Parse the issueâ€‘form submission
    #--------------------------------------------------------------------
    - name: Parse issue form
      id: parse
      uses: issue-ops/parser@v1.0.0
      with:
        body: ${{ github.event.issue.body }}
        issue-form-template: manual-test-report.yml   # inside .github/ISSUE_TEMPLATE/
        workspace: ${{ github.workspace }}

    #--------------------------------------------------------------------
    # 3) Gather all data weâ€™ll sync to the project
    #--------------------------------------------------------------------
    - name: Build field set
      id: build
      run: |
        {
          echo "test_id=${{ steps.parse.outputs.numeric_test_id }}"
          echo "estimate=${{ steps.parse.outputs.estimate_text }}"
          echo "lv_version=${{ steps.parse.outputs.labview_version }}"
          echo "bitness=${{ steps.parse.outputs.labview_bitness }}"
          echo "os_used=${{ steps.parse.outputs.os_used }}"
          echo "test_result=${{ steps.parse.outputs.test_result }}"
          echo "notes=${{ steps.parse.outputs.notes }}"
        } >> "$GITHUB_OUTPUT"

    #--------------------------------------------------------------------
    # 4) Update the organisationâ€‘wide project
    #--------------------------------------------------------------------
    - name: Update project fields
      uses: actions/github-script@v6
      env:
        PROJECT_ID:  PVT_kwDOCgMyo84AFVsT           # nodeâ€‘ID of https://github.com/orgs/ni/projects/29
        TEST_ID:      ${{ steps.build.outputs.test_id }}
        ESTIMATE:     ${{ steps.build.outputs.estimate }}
        LV_VERSION:   ${{ steps.build.outputs.lv_version }}
        BITNESS:      ${{ steps.build.outputs.bitness }}
        OS_USED:      ${{ steps.build.outputs.os_used }}
        TEST_RESULT:  ${{ steps.build.outputs.test_result }}
        NOTES:        ${{ steps.build.outputs.notes }}
      with:
        github-token: ${{ secrets.PROJECTS_PAT }}   # PAT with â€œProjectsÂ RWâ€ & â€œIssuesÂ Râ€
        script: |
          const projectId = process.env.PROJECT_ID;
          const contentId = context.payload.issue.node_id;
          const log  = (msg) => core.info(`  ${msg}`);
          const warn = (msg) => core.warning(`  ${msg}`);

          // ------------------------------------------------------------
          // 1) Ensure we have a project item for this issue
          // ------------------------------------------------------------
          async function ensureProjectItem () {
            const q = await github.graphql(`
              query ($projectId:ID!) {
                node(id:$projectId) {
                  ... on ProjectV2 {
                    title
                    items(first:100) {
                      nodes { id content { ... on Issue { id } } }
                    }
                  }
                }
              }`, { projectId });

            const proj = q.node;
            let item   = proj.items.nodes.find(n => n.content?.id === contentId);

            if (item) {
              log(`Found project item ${item.id} in â€œ${proj.title}â€`);
              return item.id;
            }

            log(`Adding issue to project â€œ${proj.title}â€â€¦`);
            const add = await github.graphql(`
              mutation ($projectId:ID!, $contentId:ID!) {
                addProjectV2ItemById(input:{ projectId:$projectId, contentId:$contentId }) {
                  item { id }
                }
              }`, { projectId, contentId });
            return add.addProjectV2ItemById.item.id;
          }

          // ------------------------------------------------------------
          // 2) Get (and cache) all projectâ€‘level fields
          // ------------------------------------------------------------
          async function fetchFields () {
            const res = await github.graphql(`
              query ($projectId:ID!) {
                node(id:$projectId) {
                  ... on ProjectV2 {
                    fields(first:100) {
                      nodes {
                        id name dataType
                        ... on ProjectV2SingleSelectField { options { id name } }
                      }
                    }
                  }
                }
              }`, { projectId });
            return res.node.fields.nodes;
          }

          // ------------------------------------------------------------
          // 3) Create a missing field (TEXT or SINGLE_SELECT)
          // ------------------------------------------------------------
          async function createField (name, type) {
            log(`Creating field â€œ${name}â€`);
            const res = await github.graphql(`
              mutation ($projectId:ID!, $name:String!, $type:ProjectV2CustomFieldDataType!) {
                createProjectV2Field(input:{
                  projectId:$projectId, name:$name, dataType:$type,
                  ${type === 'SINGLE_SELECT'
                    ? 'singleSelectOptions:[{name:"Passed"},{name:"Failed"},{name:"Needs Review"}]'
                    : ''}
                }) { field { id name dataType
                     ... on ProjectV2SingleSelectField { options { id name } } } }
              }`, { projectId, name, type });
            return res.createProjectV2Field.field;
          }

          // ------------------------------------------------------------
          // 4) Ensure a SINGLE_SELECT option exists, else create it
          // ------------------------------------------------------------
          async function ensureOption (field, optionName) {
            let opt = field.options.find(o => o.name === optionName);
            if (opt) return opt.id;

            log(`Adding option â€œ${optionName}â€ to field â€œ${field.name}â€`);
            const res = await github.graphql(`
              mutation ($projectId:ID!, $fieldId:ID!, $name:String!) {
                createProjectV2SingleSelectFieldOption(input:{
                  projectId:$projectId, fieldId:$fieldId, name:$name
                }) { option { id name } }
              }`, { projectId, fieldId: field.id, name: optionName });
            return res.createProjectV2SingleSelectFieldOption.option.id;
          }

          // ------------------------------------------------------------
          // 5) Update a field value on the item
          // ------------------------------------------------------------
          async function setField (itemId, field, val) {
            let valuePayload;

            if (field.dataType === 'SINGLE_SELECT') {
              const optId = await ensureOption(field, val);
              valuePayload = { singleSelectOptionId: optId };
            } else {
              valuePayload = { text: val };
            }

            await github.graphql(`
              mutation ($projectId:ID!, $itemId:ID!, $fieldId:ID!, $value:ProjectV2FieldValue!) {
                updateProjectV2ItemFieldValue(input:{
                  projectId:$projectId, itemId:$itemId, fieldId:$fieldId, value:$value
                }) { projectV2Item { id } }
              }`, { projectId, itemId, fieldId: field.id, value: valuePayload });

            log(`âœ… â€œ${field.name}â€ â†’ â€œ${val}â€`);
          }

          // ------------------------------------------------------------
          // MAIN FLOW
          // ------------------------------------------------------------
          log('ðŸ” Ensuring project item');
          const itemId = await ensureProjectItem();

          log('ðŸ—‚  Fetching project fields');
          const fields = await fetchFields();

          const entries = [
            { name: 'TestID',           value: process.env.TEST_ID,     type: 'TEXT' },
            { name: 'Estimate',         value: process.env.ESTIMATE,    type: 'TEXT' },
            { name: 'Operating System', value: process.env.OS_USED,     type: 'TEXT' },
            { name: 'LabVIEW Version',  value: process.env.LV_VERSION,  type: 'TEXT' },
            { name: 'LabVIEW Bitness',  value: process.env.BITNESS,     type: 'TEXT' },
            { name: 'Notes',            value: process.env.NOTES,       type: 'TEXT' },
            { name: 'Test Result',      value: process.env.TEST_RESULT, type: 'SINGLE_SELECT' }
          ];

          log('âœï¸ Updating fields');
          for (const e of entries) {
            if (!e.value) { warn(`Skipping â€œ${e.name}â€ â€“ no value`); continue; }

            let field = fields.find(f => f.name === e.name);
            if (!field) {
              field = await createField(e.name, e.type);
              fields.push(field);
            }
            await setField(itemId, field, e.value);
          }

          log('ðŸŽ‰ Project update complete');
